<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sleticalboy.github.io</id><title>sleticalboy</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-04-14T19:15:21+08:00</updated> <author> <name>sleticalboy</name> <uri>https://sleticalboy.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sleticalboy.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator> <rights> © 2021 sleticalboy </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Java 数据结构和算法</title><link href="https://sleticalboy.github.io/arithmetic/2021/04/13/java-data-structure-arithmetic/" rel="alternate" type="text/html" title="Java 数据结构和算法" /><published>2021-04-13T21:54:32+08:00</published> <updated>2021-04-13T21:54:32+08:00</updated> <id>https://sleticalboy.github.io/arithmetic/2021/04/13/java-data-structure-arithmetic/</id> <content src="https://sleticalboy.github.io/arithmetic/2021/04/13/java-data-structure-arithmetic/" /> <author> <name>sleticalboy</name> </author> <category term="arithmetic" /> <summary> 数据结构 数组 ArrayList 单链表 双链表 LinkedList 栈 先进后出 队列 算法 数组排序相关 1、冒泡 2、快排 数组其他 1、twosum 暴力法 借助 HashMap 链表相关 1、链表是否有环 暴力法 借助 HashMap（参考 HashSet 实现） 快慢指针法 2、两个链表是否相交 暴力法 借助 HashMap（参考 HashSet 实现） 将其中任一链表头尾相连，然后判断另一个链表是否有环 求出两个链表的长度差 n，长链表先走 n 步，然后短链表开始走，如果相交，则 m 步后两者 指向同一个元素 </summary> </entry> <entry><title>HTTP 和 HTTPS</title><link href="https://sleticalboy.github.io/net/2021/04/09/http-and-https/" rel="alternate" type="text/html" title="HTTP 和 HTTPS" /><published>2021-04-09T09:00:07+08:00</published> <updated>2021-04-14T19:14:55+08:00</updated> <id>https://sleticalboy.github.io/net/2021/04/09/http-and-https/</id> <content src="https://sleticalboy.github.io/net/2021/04/09/http-and-https/" /> <author> <name>sleticalboy</name> </author> <category term="net" /> <summary> HTTP 是什么 超文本传输协议 三次握手 建立一个 TCP 连接时，客户端和服务端一共需要发送 3 个包。三次握手的主要作用是确认双方 的发送能力和接收能力是否正常、指定自己的初始化序列号为后面的可靠性传输做准备。实质上 就是连接服务器指定的端口号，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。 1、三次握手过程 一开始的时候，client 处于 closed 状态；server 处于 listen 状态。 进行三次握手： 第一次：客户端给服务端发一个 SYN 报文，同时指明客户端的 ISN，此时客户端处于 SYN_SENT 状态。 第二次：服务端收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并指定自己的 ISN。 同时把客户端的 ISN + 1 作为 ACK 值，表示自己已收到客户端的 SYN，此时... </summary> </entry> <entry><title>Java 线程池</title><link href="https://sleticalboy.github.io/java/2021/04/07/java-thread-pool/" rel="alternate" type="text/html" title="Java 线程池" /><published>2021-04-07T22:43:32+08:00</published> <updated>2021-04-08T23:38:09+08:00</updated> <id>https://sleticalboy.github.io/java/2021/04/07/java-thread-pool/</id> <content src="https://sleticalboy.github.io/java/2021/04/07/java-thread-pool/" /> <author> <name>sleticalboy</name> </author> <category term="java" /> <summary> 核心参数解析 核心线程 非核心线程及存活时间 任务队列 线程工厂 拒绝策略 默认实现有四种: CallerRunsPolicy AbortPolicy DiscardPolicy DiscardOldestPolicy 任务提交 @Override public void execute(Runnable command) { // 不可提交空任务 if (command == null) throw new NullPointerException(); int c = ctl.get(); // 工作线程数目小于核心线程数，则初始化核心线程 if (workerCountOf(c) &amp;lt; corePoolSize) { ... </summary> </entry> <entry><title>Java 面向对象特征与原则</title><link href="https://sleticalboy.github.io/java/2021/04/06/java-oop-principles/" rel="alternate" type="text/html" title="Java 面向对象特征与原则" /><published>2021-04-06T21:43:00+08:00</published> <updated>2021-04-06T21:43:00+08:00</updated> <id>https://sleticalboy.github.io/java/2021/04/06/java-oop-principles/</id> <content src="https://sleticalboy.github.io/java/2021/04/06/java-oop-principles/" /> <author> <name>sleticalboy</name> </author> <category term="java" /> <summary> 面向对象三大特征 封装 属性、方法、安全、简化编程 继承 子类继承父类/实现接口、父类的属性 多态 多实现、方法重载/重写、强转 面向对象五大原则 职责单一原则 一个类应该仅有一个引起它变化的原因 开闭原则 对扩展是开放的，对修改是关闭的 里氏替换原则 基类出现的地方，子类一定可以出现 子类可以替换父类并且出现在父类能够出现的任何地方 面向接口编程 依赖倒置原则 低层依赖高层，实现依赖抽象 接口隔离原则 使用多个专门的接口比使用单个接口要好 迪米特法则 认识的人尽可能少 </summary> </entry> <entry><title>Java 并发容器之 ConcurrentHashMap（java 8）</title><link href="https://sleticalboy.github.io/java/2021/04/05/java-concurrent-hashmap/" rel="alternate" type="text/html" title="Java 并发容器之 ConcurrentHashMap（java 8）" /><published>2021-04-05T22:50:35+08:00</published> <updated>2021-04-05T22:50:35+08:00</updated> <id>https://sleticalboy.github.io/java/2021/04/05/java-concurrent-hashmap/</id> <content src="https://sleticalboy.github.io/java/2021/04/05/java-concurrent-hashmap/" /> <author> <name>sleticalboy</name> </author> <category term="java" /> <summary> #put() 方法 public V put(K key, V value) { // 插入数据 return putVal(key, value, false); } final V putVal(K key, V value, boolean onlyIfAbsent) { // key 和 value 均不能为 null，HashMap key 和 value 均可为 null if (key == null || value == null) throw new NullPointerException(); // 计算 hash 值，比 HashMap 多了一步 int hash = spread(key.hashCode()); int binCount = 0; // 节点数，用于控制链表进化为 tree 或者... </summary> </entry> </feed>
