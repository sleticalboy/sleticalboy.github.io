<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sleticalboy.github.io</id><title>sleticalboy</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-12-07T21:26:25+08:00</updated> <author> <name>sleticalboy</name> <uri>https://sleticalboy.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sleticalboy.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator> <rights> © 2021 sleticalboy </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>flutter</title><link href="https://sleticalboy.github.io/articale/2021/07/27/flutter/" rel="alternate" type="text/html" title="flutter" /><published>2021-07-27T21:33:53+08:00</published> <updated>2021-07-27T21:33:53+08:00</updated> <id>https://sleticalboy.github.io/articale/2021/07/27/flutter/</id> <content src="https://sleticalboy.github.io/articale/2021/07/27/flutter/" /> <author> <name>sleticalboy</name> </author> <category term="articale" /> <summary> flutter的issue搜索问题： Could not resolve the package ‘characters’ in ‘package:characters/characters.dart’. 解决方法：使用命令： flutter pub cache repair flutter clean </summary> </entry> <entry><title>内存泄露检测框架 Leakcanary</title><link href="https://sleticalboy.github.io/android/2021/07/12/android-leakcanary/" rel="alternate" type="text/html" title="内存泄露检测框架 Leakcanary" /><published>2021-07-12T12:51:33+08:00</published> <updated>2021-07-12T12:51:33+08:00</updated> <id>https://sleticalboy.github.io/android/2021/07/12/android-leakcanary/</id> <content src="https://sleticalboy.github.io/android/2021/07/12/android-leakcanary/" /> <author> <name>sleticalboy</name> </author> <category term="android" /> <summary> 使用 直接引入即可，会自动进行初始化 初始化原理: AppWatcherInstaller &amp;lt; provider android:name="leakcanary.internal.AppWatcherInstaller$MainProcess"/&amp;gt; 利用 ContentProvider#onCreate() 方法会先于 Application#onCreate() 方法，具体原因 涉及 app 启动流程，此处不过多讨论。 原理分析 AppWatcher.manualInstall() 默认安装 4 个 watcher： 1、ActivityWatcher 注册 ActivityLifecycleCallbacks 监听 onDestroy() 加入监听队列 2、FragmentAndViewModelWatcher 注册 FragmentLife... </summary> </entry> <entry><title>xxx 项目 Android 端重构</title><link href="https://sleticalboy.github.io/articale/2021/04/28/xxx-project-refactor/" rel="alternate" type="text/html" title="xxx 项目 Android 端重构" /><published>2021-04-28T23:21:19+08:00</published> <updated>2021-04-28T23:21:19+08:00</updated> <id>https://sleticalboy.github.io/articale/2021/04/28/xxx-project-refactor/</id> <content src="https://sleticalboy.github.io/articale/2021/04/28/xxx-project-refactor/" /> <author> <name>sleticalboy</name> </author> <category term="articale" /> <summary> 网络模块 后端 API 接口请求 HttpClient 和 AndroidHttpClient 实现 其本质为添加请求头 文件上传与下载 HttpUrlConnection 和 AndroidHttpClient 实现 图片加载中的网络请求 HttpURLConnection 实现 Web 中的网络请求 1、 WebView 拦截部分网络请求 HttpURLConnection 实现 2、Web 调试时下载资源 WebSocket 重构过程 1、隔离层抽取 HttpRequest HttpResponse HttpConfig HttpAdapter 2、调用方式收敛 原有调用方式标记为 Deprecated，统一使用新的调用方式 3、老旧方式移除 若干版本后统一移除原有实现方式 4、底层实现替换 将原有调用方式底层实现替换为新的实现方式 ... </summary> </entry> <entry><title>xxx 项目 Android 端重构</title><link href="https://sleticalboy.github.io/articale/2021/04/28/mx-project-refactor/" rel="alternate" type="text/html" title="xxx 项目 Android 端重构" /><published>2021-04-28T23:21:19+08:00</published> <updated>2021-12-07T21:12:16+08:00</updated> <id>https://sleticalboy.github.io/articale/2021/04/28/mx-project-refactor/</id> <content src="https://sleticalboy.github.io/articale/2021/04/28/mx-project-refactor/" /> <author> <name>sleticalboy</name> </author> <category term="articale" /> <summary> 网络模块 后端 API 接口请求 HttpClient 和 AndroidHttpClient 实现 其本质为添加请求头 文件上传与下载 HttpUrlConnection 和 AndroidHttpClient 实现 图片加载中的网络请求 HttpURLConnection 实现 Web 中的网络请求 1、 WebView 拦截部分网络请求 HttpURLConnection 实现 2、Web 调试时下载资源 WebSocket 重构过程 1、隔离层抽取 HttpRequest HttpResponse HttpConfig HttpAdapter 2、调用方式收敛 原有调用方式标记为 Deprecated，统一使用新的调用方式 3、老旧方式移除 若干版本后统一移除原有实现方式 4、底层实现替换 将原有调用方式底层实现替换为新的实现方式 ... </summary> </entry> <entry><title>Java 强软弱虚引用及引用队列</title><link href="https://sleticalboy.github.io/java/2021/04/21/java-reference-and-rq/" rel="alternate" type="text/html" title="Java 强软弱虚引用及引用队列" /><published>2021-04-21T23:15:08+08:00</published> <updated>2021-04-21T23:15:08+08:00</updated> <id>https://sleticalboy.github.io/java/2021/04/21/java-reference-and-rq/</id> <content src="https://sleticalboy.github.io/java/2021/04/21/java-reference-and-rq/" /> <author> <name>sleticalboy</name> </author> <category term="java" /> <summary> 四种引用类型 强引用 new object/array GC 不回收、内存不足时会 OOM 软引用 SoftReference 被软引用引用的对象，只有当内存不足时 GC 才会回收 内存敏感的高速缓存 弱引用 WeakReference 被弱引用引用的对象，只要 GC 就会被回收 虚引用 PhantomReference 虚引用不引用任何对象 当对象被回收时，可以接收到通知 引用队列 ReferenceQueue 引用的对象被回收后，引用会添加到队列中 可通过检查队列中是否有该引用来判断对象是否被回收掉 </summary> </entry> </feed>
