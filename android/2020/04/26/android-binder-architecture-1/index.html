<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.6.2"><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Android binder 架构：native 层" /><meta name="author" content="sleticalboy" /><meta property="og:locale" content="en_US" /><meta name="description" content="本文涉及到的源码路径：" /><meta property="og:description" content="本文涉及到的源码路径：" /><link rel="canonical" href="https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/" /><meta property="og:url" content="https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/" /><meta property="og:site_name" content="sleticalboy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-04-26T07:54:30+08:00" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"dateModified":"2021-01-31T22:03:05+08:00","datePublished":"2020-04-26T07:54:30+08:00","@type":"BlogPosting","headline":"Android binder 架构：native 层","mainEntityOfPage":{"@type":"WebPage","@id":"https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/"},"author":{"@type":"Person","name":"sleticalboy"},"description":"本文涉及到的源码路径：","url":"https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/","@context":"https://schema.org"}</script><title>Android binder 架构：native 层 | sleticalboy</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">sleticalboy</a></div><div class="site-subtitle font-italic">李斌的小站</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/sleticalboy" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sleticalboy','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Android binder 架构：native 层</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Android binder 架构：native 层</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 26, 2020, 7:54 AM +0800" > Apr 26, 2020 <i class="unloaded">2020-04-26T07:54:30+08:00</i> </span> by <span class="author"> sleticalboy </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 31, 2021, 10:03 PM +0800" > Jan 31 <i class="unloaded">2021-01-31T22:03:05+08:00</i> </span></div></div><div class="post-content"><p>本文涉及到的源码路径：</p><p><code class="language-plaintext highlighter-rouge">frameworks/av/media/mediaserver/main_mediaserver.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/ProcessState.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/IServiceManager.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/include/binder/IInterface.h</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/Binder.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/include/binder/IBinder.h</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/include/binder/BpBinder.h</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/libs/binder/include/binder/Binder.h</code><br /> <code class="language-plaintext highlighter-rouge">bionic/libc/kernel/uapi/linux/android/binder.h</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/cmds/servicemanager/service_manager.c</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/native/cmds/servicemanager/binder.c</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/av/media/libmedia/IMediaDeathNotifier.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</code><br /> <code class="language-plaintext highlighter-rouge">frameworks/av/media/libmedia/mediaplayer.cpp</code><br /></p><h2 id="binder-概述">binder 概述</h2><p>binder 是 Android 系统提供的一种 IPC 机制，Android 系统基本上可以看做是一个基 于 binder 的 C/S 架构，binder 像网络一样把系统的各个部分紧密地连接在一起</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/android/binder-client-server-servicimanager.png" alt="binder-c-s-sm" /></p><h2 id="从-mediaserver-看-binder">从 mediaserver 看 binder</h2><p>mediaserver 是一个由 c++ 实现的可执行程序，包括：</p><ul><li>AudioFlinger：音频中的核心服务<li>AudioPolicyService：音频系统中关于音频策略的重要服务<li>MediaPlayerService：多媒体系统中的重要服务<li>CameraService：有关相机的重要服务</ul><p>mediaserver main 函数源码</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span> <span class="n">__unused</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span> <span class="n">__unused</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1、获取一个 ProcessState 实例</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">proc</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">());</span>
    <span class="c1">// 2、获取 ServiceMananger 实例</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">sm</span><span class="p">(</span><span class="n">defaultServiceManager</span><span class="p">());</span>
    <span class="c1">// 3、初始化 MediaPlayer 服务</span>
    <span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">();</span>
    <span class="c1">// 4、创建</span>
    <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">startThreadPool</span><span class="p">();</span>
    <span class="c1">// 5、加入</span>
    <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">joinThreadPool</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="processstate-1">ProcessState （1）</h3><p>1、<code class="language-plaintext highlighter-rouge">ProcessState::self()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 单例模式，即每个进程只有一个该对象</span>
    <span class="n">Mutex</span><span class="o">::</span><span class="n">Autolock</span> <span class="n">_l</span><span class="p">(</span><span class="n">gProcessMutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gProcess</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">gProcess</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 创建 ProcessState 对象，在构造器中打开 binder</span>
    <span class="n">gProcess</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProcessState</span><span class="p">(</span><span class="s">"/dev/binder"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">gProcess</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、ProcessState 构造器</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">ProcessState</span><span class="o">::</span><span class="n">ProcessState</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mDriverName</span><span class="p">(</span><span class="n">String8</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span>
    <span class="c1">// 悄咪咪地打开 /dev/binder 设备，Android 内核为 IPC 专门设置的一个虚拟设备</span>
    <span class="p">,</span> <span class="n">mDriverFD</span><span class="p">(</span><span class="n">open_driver</span><span class="p">(</span><span class="n">driver</span><span class="p">))</span>
    <span class="c1">// 映射的是内存的起始地址</span>
    <span class="p">,</span> <span class="n">mVMStart</span><span class="p">(</span><span class="n">MAP_FAILED</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadCountLock</span><span class="p">(</span><span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadCountDecrement</span><span class="p">(</span><span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mExecutingThreadsCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mMaxThreads</span><span class="p">(</span><span class="n">DEFAULT_MAX_BINDER_THREADS</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mStarvationStartTimeMs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mManagesContexts</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mBinderContextCheckFunc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mBinderContextUserData</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadPoolStarted</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadPoolSeq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mDriverFD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// BINDER_VM_SIZE 定义为 1*2014*1024 - 4096*2 = 1M - 8k</span>
        <span class="c1">// 执行完 mmap 之后，binder 驱动会分配一块内存来接收数据</span>
        <span class="n">mVMStart</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BINDER_VM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> 
            <span class="o">|</span> <span class="n">MAP_NORESERVE</span><span class="p">,</span> <span class="n">mDriverFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>3、打开 binder 设备</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">open_driver</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 打开 /dev/binder 设备</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 通过 ioctl 校验版本号</span>
        <span class="kt">int</span> <span class="n">vers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">status_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_VERSION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vers</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="c1">// 通过 ioctl 告诉 binder 驱动，fd 最多支持 15 个线程</span>
        <span class="kt">size_t</span> <span class="n">maxThreads</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_BINDER_THREADS</span><span class="cm">/*15*/</span><span class="p">;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_SET_MAX_THREADS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxThreads</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>总结一下 ProcessState::self() 所做的事</strong>：</p><ul><li>打开 <code class="language-plaintext highlighter-rouge">/dev/binder</code> 设备，及打开与内核的 binder 驱动的通道；<li>对打开的文件句柄使用 <code class="language-plaintext highlighter-rouge">mmap</code>，让 binder 驱动分配一块内存来接收数据；<li>由于 ProcessState 是单例，因此每个进程只会打开设备一次</ul><h3 id="defaultservicemanager-函数-2">defaultServiceManager() 函数 （2）</h3><p>1、<code class="language-plaintext highlighter-rouge">IServiceManager.cpp::defaultServiceManager()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">defaultServiceManager</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 单例模式，若已初始化则直接返回</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">gDefaultServiceManager</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="c1">// 自动锁，在程序返回时会自动释放</span>
        <span class="n">AutoMutex</span> <span class="n">_l</span><span class="p">(</span><span class="n">gDefaultServiceManagerLock</span><span class="p">);</span>
        <span class="c1">// 若对象未创建，则等待直到创建完成</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// interface_cast 这个宏是什么作用呢？见 4.2</span>
            <span class="n">gDefaultServiceManager</span> <span class="o">=</span> <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span><span class="p">(</span>
                <span class="c1">// 此处传入的 NULL 参数非常关键，下面来分析一下</span>
                <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getContextObject</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
            <span class="c1">// 睡一会儿，休息休息</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">gDefaultServiceManager</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、<code class="language-plaintext highlighter-rouge">ProcessState::self()-&gt;getContextObject(NULL)</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">getContextObject</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="cm">/*caller*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 函数返回值是 IBinder</span>
    <span class="k">return</span> <span class="n">getStrongProxyForHandle</span><span class="p">(</span><span class="mi">0</span><span class="cm">/*NULL*/</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>3、<code class="language-plaintext highlighter-rouge">ProcessState::self()-&gt;getStrongProxyForHandle()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">getStrongProxyForHandle</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">AutoMutex</span> <span class="n">_l</span><span class="p">(</span><span class="n">mLock</span><span class="p">);</span>
    <span class="c1">// 根据索引查询对应的句柄，若未找到则创建一个新的并返回</span>
    <span class="n">handle_entry</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">lookupHandleLocked</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 初始状态下，e-&gt;binder 是 NULL</span>
        <span class="n">IBinder</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">binder</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span><span class="o">-&gt;</span><span class="n">attemptIncWeak</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 此时传入的 handle 为 0，对应的就是 ServiceManager</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// ping 下，看看是不是挂掉了</span>
                <span class="n">Parcel</span> <span class="n">data</span><span class="p">;</span>
                <span class="c1">// IPCThreadState 稍后再分析</span>
                <span class="n">status_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">IBinder</span><span class="o">::</span><span class="n">PING_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DEAD_OBJECT</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 创建 BpBinder（静态工厂），即 new BpBinder(handle)</span>
            <span class="c1">// 接下来分析 BpBinder 与 BBinder </span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">BpBinder</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
            <span class="c1">// 填充内容</span>
            <span class="n">e</span><span class="o">-&gt;</span><span class="n">binder</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">getWeakRefs</span><span class="p">();</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// new BpBinder(0)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>4、BpBinder 与 BBinder 是什么？</p><p>BpBinder 与 BBinder 都是 Android 中与 Binder 通信相关的代表，他们都由 IBinder 派生，如下是他们的族谱： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/android/bind-ibinder-family.png" alt="ibinder-family" /></p><ul><li>BpBinder 是客户端用来与 Server 交互的代理类（p 可理解为 proxy）；<li>BBinder 则是与 proxy 相对的一端，即 pxory 交互的目标（服务端代理）<li>BpBinder 与 BBinder 一一对应，即 BpBinderA 只能与 BBinderA 对应</ul><p>① 为什么在 <code class="language-plaintext highlighter-rouge">defaultServiceManager()</code> 中创建了 BpBinder 而不是 BBinder？</p><ul><li>目前，我们还是 ServiceManager 的客户端，所以用 BpBinder 来进行交互</ul><p>② BpBinder 如何与 BBinder 一一对应？</p><ul><li>还记得上述代码中的 <code class="language-plaintext highlighter-rouge">handle</code> 么，binder 系统是用 <code class="language-plaintext highlighter-rouge">handle</code> 来进行标识的</ul><p>③ <code class="language-plaintext highlighter-rouge">handle = 0</code> 时，表示什么？</p><ul><li>0 在 binder 系统中有重要的含义，即 0 代表的就是 ServiceManager 所对应的 BBinder。可以理解为 0 号服务就是 ServiceManager，0 号服务管理其他服务</ul><p>4.1、<code class="language-plaintext highlighter-rouge">BpBinder</code> 构造</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">BpBinder</span><span class="o">::</span><span class="n">BpBinder</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">trackedUid</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mAlive</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mObitsSent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mObituaries</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mTrackedUid</span><span class="p">(</span><span class="n">trackedUid</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 怎么感觉这里什么也没做呢？回想代码是从 defaultServiceManager() 中开始</span>
    <span class="c1">// 的，回头看下我们是不是有什么细节遗漏了？哦！原来是 interface_cast 这个宏</span>
    <span class="n">extendObjectLifetime</span><span class="p">(</span><span class="n">OBJECT_LIFETIME_WEAK</span><span class="p">);</span>
    <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incWeakHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="c1">// 最终返回到 defaultServiceManager() 中</span>
<span class="p">}</span>
</pre></table></code></div></div><p>5、被遗忘的宏 <code class="language-plaintext highlighter-rouge">interface_cast</code> 从 <code class="language-plaintext highlighter-rouge">IInterface.h</code> 中来</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">INTERFACE</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">INTERFACE</span><span class="o">&gt;</span> <span class="n">interface_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">INTERFACE</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 对 defaultServiceManager() 中的 interface_cast&lt;IServiceManager&gt;(obj) 展开如下：</span>
<span class="kr">inline</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">interface_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 兜兜转转现在又回到 IServiceManager 中了</span>
    <span class="k">return</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>6、千呼万唤始出来 <code class="language-plaintext highlighter-rouge">IServiceManager.cpp::asInterface</code></p><ul><li>IServiceManager 定义了 ServiceManager 所需的一系列业务接口</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">IServiceManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IInterface</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 重要的宏，稍后分析</span>
    <span class="n">DECLARE_META_INTERFACE</span><span class="p">(</span><span class="n">ServiceManager</span><span class="p">)</span>

    <span class="cm">/* 以下是 ServiceManager 中所需的一系列业务接口 */</span>
    <span class="c1">// 从 ServiceManager 中查询服务</span>
    <span class="k">virtual</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">getService</span><span class="p">(</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">checkService</span><span class="p">(</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 向 ServiceManager 添加/注册一个服务</span>
    <span class="k">virtual</span> <span class="n">status_t</span> <span class="n">addService</span><span class="p">(</span><span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">service</span><span class="p">,</span>
                                <span class="kt">bool</span> <span class="n">allowIsolated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">dumpsysFlags</span> <span class="o">=</span> <span class="n">DUMP_FLAG_PRIORITY_DEFAULT</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 列出已注册的所有服务</span>
    <span class="k">virtual</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String16</span><span class="o">&gt;</span> <span class="n">listServices</span><span class="p">(</span><span class="kt">int</span> <span class="n">dumpsysFlags</span> <span class="o">=</span> <span class="n">DUMP_FLAG_PRIORITY_ALL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 重要的宏，稍后分析</span>
<span class="n">IMPLEMENT_META_INTERFACE</span><span class="p">(</span><span class="n">ServiceManager</span><span class="p">,</span> <span class="s">"android.os.IServiceManager"</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>通过宏 <code class="language-plaintext highlighter-rouge">DECLARE_META_INTERFACE</code> 和宏 <code class="language-plaintext highlighter-rouge">IMPLEMENT_META_INTERFACE</code> 将业务与通信结合</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="c1">// 宏定义：声明</span>
<span class="cp">#define DECLARE_META_INTERFACE(INTERFACE)                               \
    static const ::android::String16 descriptor;                        \
    static ::android::sp&lt;I##INTERFACE&gt; asInterface(                     \
            const ::android::sp&lt;::android::IBinder&gt;&amp; obj);              \
    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \
    I##INTERFACE();                                                     \
    virtual ~I##INTERFACE();                                            \

</span><span class="c1">// 宏定义：实现</span>
<span class="cp">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    const ::android::String16 I##INTERFACE::descriptor(NAME);           \
    const ::android::String16&amp;                                          \
            I##INTERFACE::getInterfaceDescriptor() const {              \
        return I##INTERFACE::descriptor;                                \
    }                                                                   \
    ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \
            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \
    {                                                                   \
        ::android::sp&lt;I##INTERFACE&gt; intr;                               \
        if (obj != NULL) {                                              \
            intr = static_cast&lt;I##INTERFACE*&gt;(                          \
                obj-&gt;queryLocalInterface(                               \
                        I##INTERFACE::descriptor).get());               \
            if (intr == NULL) {                                         \
                intr = new Bp##INTERFACE(obj);                          \
            }                                                           \
        }                                                               \
        return intr;                                                    \
    }                                                                   \
    I##INTERFACE::I##INTERFACE() { }                                    \
    I##INTERFACE::~I##INTERFACE() { }                                   \
</span></pre></table></code></div></div><ul><li>将以上两个宏代入 ServiceManager 后展开如下：</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="c1">/////////////////////// 声明一些函数和变量</span>
<span class="k">static</span> <span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">String16</span> <span class="n">descriptor</span><span class="p">;</span>
<span class="k">static</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">asInterface</span><span class="p">(</span>
    <span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">sp</span><span class="o">&lt;::</span><span class="n">android</span><span class="o">::</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">virtual</span> <span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">String16</span><span class="o">&amp;</span> <span class="n">getInterfaceDescriptor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">// 定义构造函数和析构函数</span>
<span class="n">IServiceManager</span><span class="p">();</span>
<span class="k">virtual</span> <span class="o">~</span><span class="n">IServiceManager</span><span class="p">();</span>

<span class="c1">/////////////////////// 实现上述声明的函数和变量</span>
<span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">String16</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">descriptor</span><span class="p">(</span><span class="s">"android.os.IServiceManager"</span><span class="p">)</span>
<span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">String16</span><span class="o">&amp;</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">getInterfaceDescriptor</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// 即 android.os.IServiceManager</span>
    <span class="k">return</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">descriptor</span>
<span class="p">}</span>
<span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span>
    <span class="k">const</span> <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">sp</span><span class="o">&lt;::</span><span class="n">android</span><span class="o">::</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">android</span><span class="o">::</span><span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">intr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">intr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">*&gt;</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">-&gt;</span><span class="n">queryLocalInterface</span><span class="p">(</span><span class="n">IServiceManager</span><span class="o">::</span><span class="n">descriptor</span><span class="p">).</span><span class="n">get</span><span class="p">());</span>
        <span class="c1">// 第一次肯定会进入以下分支</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">intr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 创建 BpServiceManager（IServiceManager 的内嵌类）</span>
            <span class="c1">// 这里的 obj 是在 #3 中创建的 BpBinder(0)</span>
            <span class="n">intr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BpServiceManager</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">intr</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 实现构造函数和析构函数</span>
<span class="n">IServiceManager</span><span class="o">::</span><span class="n">IServiceManager</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">IServiceManager</span><span class="o">::~</span><span class="n">IServiceManager</span><span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>7、IServiceManager 家族族谱如下： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/android/binder-iservicemanager-family.png" alt="iservicemanager-family" /></p><p>可知：</p><ul><li>IServiceManager、BpServiceManager 和 BnServiceManager 都与业务逻辑相关<li>BnServiceManager 同时从 IServiceManager BBinder 派生，表示它可直接参与 Binder 通信<li>BpServiceManager 虽然从 BpInterface 中派生，但是这条分支似乎与 BpBinder 没有关系<li>BnServiceManager 是一个虚类，它的业务函数最终需要子类来实现</ul><p>7.1、<code class="language-plaintext highlighter-rouge">IServiceManager.cpp::BpServiceManager</code> 类</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">BpServiceManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BpInterface</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">BpServiceManager</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">impl</span><span class="p">)</span>
        <span class="c1">// 这里调用父类构造，impl 是 IBinder 类型与 Binder 相关，实际是 BpBinder 对象</span>
        <span class="o">:</span> <span class="n">BpInterface</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
        <span class="c1">// 省略具体的业务函数: </span>
        <span class="c1">// checkService(), addService(), getService(), listService()</span>
<span class="p">}</span>
</pre></table></code></div></div><p>7.2、<code class="language-plaintext highlighter-rouge">IInterface.h::BpInterface</code> 类</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">INTERFACE</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BpInterface</span><span class="o">&lt;</span><span class="n">INTERFACE</span><span class="o">&gt;::</span><span class="n">BpInterface</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">remote</span><span class="p">)</span>
    <span class="c1">// 继续调用父类构造，其具体实现在 Binder.cpp 中</span>
    <span class="o">:</span> <span class="n">BpRefBase</span><span class="p">(</span><span class="n">remote</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></table></code></div></div><p>7.3、<code class="language-plaintext highlighter-rouge">Binder.cpp::BpRefBase</code> 类</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">BpRefBase</span><span class="o">::</span><span class="n">BpRefBase</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">)</span>
    <span class="c1">// 此处的 mRemote 即上面创建的 BpBinder(0)</span>
    <span class="o">:</span> <span class="n">mRemote</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span> <span class="n">mRefs</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">mState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">extendObjectLifetime</span><span class="p">(</span><span class="n">OBJECT_LIFETIME_WEAK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mRemote</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mRemote</span><span class="o">-&gt;</span><span class="n">incStrong</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>           <span class="c1">// Removed on first IncStrong().</span>
        <span class="n">mRefs</span> <span class="o">=</span> <span class="n">mRemote</span><span class="o">-&gt;</span><span class="n">createWeak</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// Held for our entire lifetime.</span>
    <span class="p">}</span>
    <span class="c1">// 最终：BpServiceManager::mRemote 指向 BpBinder()</span>
<span class="p">}</span>
</pre></table></code></div></div><p>8、总结一下 <code class="language-plaintext highlighter-rouge">defaultServiceManager()</code> 函数</p><ul><li>创建 BpBinder 对象，其 handle 值为 0<li>创建 BpServiceManager 对象，其 mRemote 指向 BpBinder(0)<li>BpServiceManager 内部实现了 IServiceManager 中定义的业务接口</ul><h3 id="注册-mediaplayerservice-3">注册 MediaPlayerService （3）</h3><p>1、<code class="language-plaintext highlighter-rouge">MediaPlayService.cpp::instantiate()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">defaultServiceManager</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addService</span><span class="p">(</span>
        <span class="n">String16</span><span class="p">(</span><span class="s">"media.player"</span><span class="p">),</span> <span class="k">new</span> <span class="n">MediaPlayerService</span><span class="p">());</span>
    <span class="c1">// 即 BpServiceManager::addService()</span>
<span class="p">}</span>
</pre></table></code></div></div><p>1.1、中转站一 <code class="language-plaintext highlighter-rouge">IServiceManager.cpp::BpServiceManager::addService()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">virtual</span> <span class="n">status_t</span> <span class="nf">addService</span><span class="p">(</span><span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">service</span><span class="p">,</span>
                            <span class="kt">bool</span> <span class="n">allowIsolated</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dumpsysPriority</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// data 是要打包发送的数据，reply 是要接收的数据</span>
    <span class="n">Parcel</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeInterfaceToken</span><span class="p">(</span><span class="n">IServiceManager</span><span class="o">::</span><span class="n">getInterfaceDescriptor</span><span class="p">());</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeString16</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">allowIsolated</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">dumpsysPriority</span><span class="p">);</span>
    <span class="c1">// 打包发送并接收数据</span>
    <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">remote</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span><span class="n">ADD_SERVICE_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">);</span>
    <span class="c1">// remote() 方法返回 mRemote 即 BpBinder 对象</span>
    <span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span> <span class="o">?</span> <span class="n">reply</span><span class="p">.</span><span class="n">readExceptionCode</span><span class="p">()</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>1.2、中转站二 <code class="language-plaintext highlighter-rouge">BpBinder.cpp::transact()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">BpBinder</span><span class="o">::</span><span class="n">transact</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mAlive</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 把实际的苦活交给 IPCThreadState 来干，下面着重分析</span>
        <span class="n">status_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span>
            <span class="n">mHandle</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DEAD_OBJECT</span><span class="p">)</span> <span class="n">mAlive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">DEAD_OBJECT</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>2、真正脚踏实地干活的 <code class="language-plaintext highlighter-rouge">IPCThreadState</code> 类</p><p>2.1、线程中单例 <code class="language-plaintext highlighter-rouge">IPCThreadState::self()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">IPCThreadState</span><span class="o">*</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 每个线程只会有一个实例</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gHaveTLS</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">restart:</span>
        <span class="c1">// 如果已经 set，则根据 key 获取相关内容</span>
        <span class="k">const</span> <span class="n">pthread_key_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">gTLS</span><span class="p">;</span>
        <span class="c1">// TLS 全称为 Thread Local Storage，线程本地存储，顾名思义这是线程内部</span>
        <span class="c1">// 的私有空间，并不会与其他线程共享</span>
        <span class="c1">// linux 内核提供了 pthread_set/getspecific() 函数来设置/获取线程私有</span>
        <span class="c1">// 空间的内容所以有 get 的地方肯定有 set</span>
        <span class="n">IPCThreadState</span><span class="o">*</span> <span class="n">st</span> <span class="o">=</span> <span class="p">(</span><span class="n">IPCThreadState</span><span class="o">*</span><span class="p">)</span><span class="n">pthread_getspecific</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="k">return</span> <span class="n">st</span><span class="p">;</span>
        <span class="c1">// 构造函数中会调用 set 方法</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">IPCThreadState</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gHaveTLS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果没有设置过，则先创建 key 再进行设置</span>
        <span class="kt">int</span> <span class="n">key_create_value</span> <span class="o">=</span> <span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLS</span><span class="p">,</span> <span class="n">threadDestructor</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key_create_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 创建 key 失败，释放锁并返回 NULL</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">gHaveTLS</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gTLSMutex</span><span class="p">);</span>
    <span class="c1">// 跳转到 set 的地方去，这个地方用的妙啊！</span>
    <span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.2、<code class="language-plaintext highlighter-rouge">IPCThreadState</code> 构造函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">IPCThreadState</span><span class="o">::</span><span class="n">IPCThreadState</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">mProcess</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()),</span>
      <span class="n">mStrictModePolicy</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
      <span class="n">mLastTransactionBinderFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 有 get 必有 set，Android 诚不我欺</span>
    <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">gTLS</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">clearCaller</span><span class="p">();</span>
    <span class="c1">// mIn 和 mOut 是两个 Parcel 类型的对象</span>
    <span class="c1">// mIn 可以看做接收来自 Binder 数据的缓冲区</span>
    <span class="c1">// mOut 可以看做发送数据到 Binder 的缓冲区</span>
    <span class="n">mIn</span><span class="p">.</span><span class="n">setDataCapacity</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
    <span class="n">mOut</span><span class="p">.</span><span class="n">setDataCapacity</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.3、马不停蹄的 <code class="language-plaintext highlighter-rouge">transact()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">transact</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status_t</span> <span class="n">err</span><span class="p">;</span>

    <span class="n">flags</span> <span class="o">|=</span> <span class="n">TF_ACCEPT_FDS</span><span class="p">;</span>

    <span class="c1">// BR_ 开头的是回复消息，定义在 binder_driver_return_protocol 枚举中</span>
    <span class="c1">// BC_ 开头的是发送消息，定义在 binder_driver_command_protocol 枚举中</span>
    <span class="c1">// 向 binder 发送数据</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">writeTransactionData</span><span class="p">(</span><span class="n">BC_TRANSACTION</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">setError</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// TF_ONE_WAY 这个是什么东东？</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 接收 binder 返回的数据</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">waitForResponse</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">Parcel</span> <span class="n">fakeReply</span><span class="p">;</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">waitForResponse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fakeReply</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">waitForResponse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>2.3.1、发送数据 <code class="language-plaintext highlighter-rouge">writeTransactionData()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">writeTransactionData</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">binderFlags</span><span class="p">,</span>
    <span class="kt">int32_t</span> <span class="n">handle</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">status_t</span><span class="o">*</span> <span class="n">statusBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">binder_transaction_data</span> <span class="n">tr</span><span class="p">;</span>

    <span class="c1">// 将数据填充到 binder_transaction_data 结构体中</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don't pass uninitialized stack data to a remote process */</span>
    <span class="c1">// handle 值传递给 target，用来标识 target 端，0 表示 ServiceManager</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">binderFlags</span><span class="p">;</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">sender_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">sender_euid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 检查数据是否合法</span>
    <span class="k">const</span> <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">errorCheck</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 继续填充数据</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">ipcDataSize</span><span class="p">();</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">ipcData</span><span class="p">();</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">offsets_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">ipcObjectsCount</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">binder_size_t</span><span class="p">);</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">ipcObjects</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">statusBuffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TF_STATUS_CODE 又是什么东东</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">TF_STATUS_CODE</span><span class="p">;</span>
        <span class="o">*</span><span class="n">statusBuffer</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status_t</span><span class="p">);</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">statusBuffer</span><span class="p">);</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">offsets_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 将数据填充到缓冲区等待发送，那实际发送数据是在哪里呢？</span>
    <span class="n">mOut</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
    <span class="n">mOut</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.3.2、接收数据 <code class="language-plaintext highlighter-rouge">waitForResponse()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">waitForResponse</span><span class="p">(</span><span class="n">Parcel</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span>
    <span class="n">status_t</span> <span class="o">*</span><span class="n">acquireResult</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">err</span><span class="p">;</span>
    <span class="c1">// 等待直到返回或者错误</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 重要的 talkViewDriver() 函数，直接与 binder 驱动进行交互</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">err</span><span class="o">=</span><span class="n">talkWithDriver</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">errorCheck</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mIn</span><span class="p">.</span><span class="n">dataAvail</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="c1">// 接下来要执行的命令</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="nl">default:</span>
                <span class="c1">// 执行命令</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">finish:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acquireResult</span><span class="p">)</span> <span class="o">*</span><span class="n">acquireResult</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reply</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">setError</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
        <span class="n">mLastError</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.3.3、<code class="language-plaintext highlighter-rouge">executeCommand()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">executeCommand</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BBinder</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">RefBase</span><span class="o">::</span><span class="n">weakref_type</span><span class="o">*</span> <span class="n">refs</span><span class="p">;</span>
    <span class="n">status_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NO_ERROR</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">BR_ERROR</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">BR_OK</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="c1">// 重点看这个，其他的先略过</span>
        <span class="k">case</span> <span class="n">BR_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">binder_transaction_data</span> <span class="n">tr</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

            <span class="n">Parcel</span> <span class="n">buffer</span><span class="p">;</span>
            <span class="n">buffer</span><span class="p">.</span><span class="n">ipcSetDataReference</span><span class="p">(</span>
                <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span><span class="p">),</span>
                <span class="n">tr</span><span class="p">.</span><span class="n">data_size</span><span class="p">,</span>
                <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">binder_size_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span><span class="p">),</span>
                <span class="n">tr</span><span class="p">.</span><span class="n">offsets_size</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">binder_size_t</span><span class="p">),</span> <span class="n">freeBuffer</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>

            <span class="k">const</span> <span class="n">pid_t</span> <span class="n">origPid</span> <span class="o">=</span> <span class="n">mCallingPid</span><span class="p">;</span>
            <span class="k">const</span> <span class="n">uid_t</span> <span class="n">origUid</span> <span class="o">=</span> <span class="n">mCallingUid</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">origStrictModePolicy</span> <span class="o">=</span> <span class="n">mStrictModePolicy</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">origTransactionBinderFlags</span> <span class="o">=</span> <span class="n">mLastTransactionBinderFlags</span><span class="p">;</span>

            <span class="n">mCallingPid</span> <span class="o">=</span> <span class="n">tr</span><span class="p">.</span><span class="n">sender_pid</span><span class="p">;</span>
            <span class="n">mCallingUid</span> <span class="o">=</span> <span class="n">tr</span><span class="p">.</span><span class="n">sender_euid</span><span class="p">;</span>
            <span class="n">mLastTransactionBinderFlags</span> <span class="o">=</span> <span class="n">tr</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>

            <span class="n">Parcel</span> <span class="n">reply</span><span class="p">;</span>
            <span class="n">status_t</span> <span class="n">error</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 将 tr.target.ptr 强转为 RefBase::weakref_type 指针后调用 </span>
                <span class="c1">// attemptIncStrong() 方法，获取一个强引用</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">RefBase</span><span class="o">::</span><span class="n">weakref_type</span><span class="o">*&gt;</span><span class="p">(</span>
                        <span class="n">tr</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">attemptIncStrong</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// 将 tr.cookie 强转为 BBinder 指针后调用 transact() 方法</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">BBinder</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">cookie</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span>
                        <span class="n">tr</span><span class="p">.</span><span class="n">code</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">,</span> <span class="n">tr</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
                    <span class="c1">// 将 tr.cookie 强转为 BBinder 指针后调用 decStrong() 方法</span>
                    <span class="c1">// 减少一次强引用计数</span>
                    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">BBinder</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">cookie</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">decStrong</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="n">error</span> <span class="o">=</span> <span class="n">UNKNOWN_TRANSACTION</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// the_context_object 是 IPCThreadState 中定义的一个全局变量：</span>
                <span class="c1">// sp&lt;BBinder&gt; the_context_object;，可通过 setTheContextObject() 来设置</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">the_context_object</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">code</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">,</span> <span class="n">tr</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// 又又又又遇到了 TF_ONE_WAY</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">tr</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="n">reply</span><span class="p">.</span><span class="n">setError</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
                <span class="n">sendReply</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">mCallingPid</span> <span class="o">=</span> <span class="n">origPid</span><span class="p">;</span>
            <span class="n">mCallingUid</span> <span class="o">=</span> <span class="n">origUid</span><span class="p">;</span>
            <span class="n">mStrictModePolicy</span> <span class="o">=</span> <span class="n">origStrictModePolicy</span><span class="p">;</span>
            <span class="n">mLastTransactionBinderFlags</span> <span class="o">=</span> <span class="n">origTransactionBinderFlags</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="n">BR_DEAD_BINDER</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// 收到驱动的指示：service 挂掉了，BpBinder 要做一些事儿了</span>
            <span class="n">BpBinder</span> <span class="o">*</span><span class="n">proxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">BpBinder</span><span class="o">*</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="n">readPointer</span><span class="p">();</span>
            <span class="c1">// BpBinder 做的事儿在这，有趣的地方，稍后再看</span>
            <span class="n">proxy</span><span class="o">-&gt;</span><span class="n">sendObituary</span><span class="p">();</span>
            <span class="n">mOut</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">BC_DEAD_BINDER_DONE</span><span class="p">);</span>
            <span class="n">mOut</span><span class="p">.</span><span class="n">writePointer</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">proxy</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">BR_SPAWN_LOOPER</span><span class="p">:</span>
            <span class="c1">// 收到驱动的指示：要创建一个新的线程用来与 binder 通信</span>
            <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">spawnPooledThread</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.4、与 binder 交互 <code class="language-plaintext highlighter-rouge">talkWithDriver()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">talkWithDriver</span><span class="p">(</span><span class="kt">bool</span> <span class="n">doReceive</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">binder_write_read</span> <span class="n">bwr</span><span class="p">;</span>

    <span class="c1">// Is the read buffer empty?</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">needRead</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">dataPosition</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">dataSize</span><span class="p">();</span>

    <span class="c1">// We don't want to write anything if we are still reading</span>
    <span class="c1">// from data left in the input buffer and the caller</span>
    <span class="c1">// has requested to read the next data.</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">outAvail</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">doReceive</span> <span class="o">||</span> <span class="n">needRead</span><span class="p">)</span> <span class="o">?</span> <span class="n">mOut</span><span class="p">.</span><span class="n">dataSize</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 结构体填充</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">=</span> <span class="n">outAvail</span><span class="p">;</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">mOut</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>

    <span class="c1">// This is what we'll read.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">doReceive</span> <span class="o">&amp;&amp;</span> <span class="n">needRead</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 接收数据缓冲区填充，如果接收到数据就直接填充在 mIn 中</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">dataCapacity</span><span class="p">();</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Return immediately if there is nothing to do.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>

    <span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">status_t</span> <span class="n">err</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="c1">// 通过 ioctl 与 binder 设备进行交互，暂时先到这里</span>
        <span class="c1">// 再向下深入的话需要去分析驱动层的源码了</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span><span class="p">,</span> <span class="n">BINDER_WRITE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="k">else</span> 
            <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mDriverFD</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">&lt;</span> <span class="n">mOut</span><span class="p">.</span><span class="n">dataSize</span><span class="p">())</span>
                <span class="n">mOut</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span><span class="p">);</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">mOut</span><span class="p">.</span><span class="n">setDataSize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">processPostWriteDerefs</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mIn</span><span class="p">.</span><span class="n">setDataSize</span><span class="p">(</span><span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span><span class="p">);</span>
            <span class="n">mIn</span><span class="p">.</span><span class="n">setDataPosition</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="startthreadpool-和-jointhreadpool-45">startThreadPool() 和 joinThreadPool() （4/5）</h3><p>1、<code class="language-plaintext highlighter-rouge">ProcessState.cpp::startThreadPool()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">startThreadPool</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AutoMutex</span> <span class="n">_l</span><span class="p">(</span><span class="n">mLock</span><span class="p">);</span>
    <span class="c1">// 如果未执行过才会执行以下分支</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mThreadPoolStarted</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mThreadPoolStarted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">spawnPooledThread</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>1.1、<code class="language-plaintext highlighter-rouge">ProcessState.cpp::spawnPooledThread()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">spawnPooledThread</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 此处的 isMain 为 true</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mThreadPoolStarted</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 生成线程名，其格式为："Binder:%d_%X", pid, seq</span>
        <span class="n">String8</span> <span class="n">name</span> <span class="o">=</span> <span class="n">makeBinderThreadName</span><span class="p">();</span>
        <span class="c1">// 创建 PoolThread 并执行</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PoolThread</span><span class="p">(</span><span class="n">isMain</span><span class="cm">/*true*/</span><span class="p">);</span>
        <span class="n">t</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">string</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>1.2、ProcessState 的内嵌类 PoolThread:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">PoolThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Thread</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">PoolThread</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span>
        <span class="c1">// 调用父类，将值传递给 mIsMain(true) </span>
        <span class="o">:</span> <span class="n">mIsMain</span><span class="p">(</span><span class="n">isMain</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">threadLoop</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// mIsMain 为 true，最终调用到 IPCThreadState</span>
        <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">joinThreadPool</span><span class="p">(</span><span class="n">mIsMain</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>    
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">mIsMain</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、<code class="language-plaintext highlighter-rouge">IPCThreadState.cpp::joinThreadPool()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">joinThreadPool</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isMain</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// isMain 为 true, 此处写入 BC_ENTER_LOOPER 指令，进入循环</span>
    <span class="n">mOut</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">isMain</span> <span class="o">?</span> <span class="n">BC_ENTER_LOOPER</span> <span class="o">:</span> <span class="n">BC_REGISTER_LOOPER</span><span class="p">);</span>
    <span class="n">status_t</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="c1">// 处理已经 dead 的 BBinder 对象</span>
        <span class="n">processPendingDerefs</span><span class="p">();</span>
        <span class="c1">// 不停地获取并执行下一条指令</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">getAndExecuteCommand</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">);</span>
    <span class="c1">// 退出循环</span>
    <span class="n">mOut</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">BC_EXIT_LOOPER</span><span class="p">);</span>
    <span class="n">talkWithDriver</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.1、<code class="language-plaintext highlighter-rouge">IPCThreadState.cpp::getAndExecuteCommand()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">getAndExecuteCommand</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">status_t</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="c1">// 发送指令，读取请求</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">talkWithDriver</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">IN</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">dataAvail</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IN</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32_t</span><span class="p">))</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="c1">// 读取一条指令</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">mIn</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
        <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span> <span class="o">&gt;=</span> <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mMaxThreads</span> <span class="o">&amp;&amp;</span>
                <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">=</span> <span class="n">uptimeMillis</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
        <span class="c1">// 执行命令，构成了循环调用</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">executeCommand</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
        <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mExecutingThreadsCount</span> <span class="o">&lt;</span> <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mMaxThreads</span> <span class="o">&amp;&amp;</span>
                <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mStarvationStartTimeMs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountDecrement</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mProcess</span><span class="o">-&gt;</span><span class="n">mThreadCountLock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>总结：</strong></p><ul><li>1、从以上来看，有几个 Thread 在为 Service 服务呢？<ul><li>startThreadPool 中启动的线程通过 joinThreadPool 读取 binder 设备，查看是否有请求<li>main 线程也调用 joinThreadPool 读取 binder 设备，查看是否有请求</ul><li>2、由此可见，binder 设备是支持多线程操作的<li>3、Binder 通信和基于 Binder 通信的业务之间的关系：<ul><li>Binder 是通信机制<li>业务可以基于 Binder 通信，当然也可以使用其他的 IPC 手段</ul><li>4、binder 通信和业务层的关系图如下：</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/android/binder-transport-logic.png" alt="binder-transport-logic" /></p><h2 id="服务大总管-service-manager">服务大总管 service manager</h2><p>前面提到 defaultServiceMannager() 返回一个 BpServiceManager 对象，通过它可以把 请求发送给 handle 值为 0 的目的端，即 BnServiceManager 来处理请求，但是源码中 并没有这样一个类；然而系统提供了一个 service_manager.c 程序，它完成的就是 BnServiceManager 的工作。</p><h3 id="servicemanager-原理">ServiceManager 原理</h3><p>1、<code class="language-plaintext highlighter-rouge">service_manager.c::main()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
    <span class="k">union</span> <span class="n">selinux_callback</span> <span class="n">cb</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="s">"/dev/binder"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ①打开 binder 设备，mmap 大小为 128k</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">binder_open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 打开失败，打印 log 并返回</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ②让自己成为大管家，是不是把自己的 handle 设置为 0 呢？</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">binder_become_context_manager</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// selinux 配置项</span>
    <span class="n">cb</span><span class="p">.</span><span class="n">func_audit</span> <span class="o">=</span> <span class="n">audit_callback</span><span class="p">;</span>
    <span class="n">selinux_set_callback</span><span class="p">(</span><span class="n">SELINUX_CB_AUDIT</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
    <span class="n">cb</span><span class="p">.</span><span class="n">func_log</span> <span class="o">=</span> <span class="n">selinux_log_callback</span><span class="p">;</span>
    <span class="n">selinux_set_callback</span><span class="p">(</span><span class="n">SELINUX_CB_LOG</span><span class="p">,</span> <span class="n">cb</span><span class="p">);</span>
    <span class="n">sehandle</span> <span class="o">=</span> <span class="n">selinux_android_service_context_handle</span><span class="p">();</span>
    <span class="n">selinux_status_open</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sehandle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getcon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">service_manager_context</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// ③开始干活儿，处理客户端发过来的请求</span>
    <span class="c1">// 参数 func 是一个函数指针，指向 svcmgr_handler 函数，用于解析客户端请求</span>
    <span class="n">binder_loop</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">svcmgr_handler</span><span class="cm">/*binder_handler func*/</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、打开 binder 设备：<code class="language-plaintext highlighter-rouge">service_manager.c::open_binder()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="nf">binder_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">driver</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mapsize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="c1">// 打开设备，返回文件句柄</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="c1">// 内存映射</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">mapsize</span> <span class="o">=</span> <span class="n">mapsize</span><span class="p">;</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">bs</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>3、成为老大：<code class="language-plaintext highlighter-rouge">service_manager.c::binder_become_context_manager()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">binder_become_context_manager</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 此处传递的参数是 0，指令是 BINDER_SET_CONTEXT_MGR</span>
    <span class="k">return</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_SET_CONTEXT_MGR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>4、开始干活儿：<code class="language-plaintext highlighter-rouge">service_manager.c::binder_loop()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">binder_loop</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="n">binder_handler</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">binder_write_read</span> <span class="n">bwr</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">readbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="c1">// 填充结构体参数</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">write_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">write_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">bwr</span><span class="p">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">readbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BC_ENTER_LOOPER</span><span class="p">;</span>
    <span class="c1">// 先执行一个 BC_ENTER_LOOPER 指令</span>
    <span class="n">binder_write</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">readbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
    <span class="c1">// 开始无限循环</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// 继续填充参数</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">readbuf</span><span class="p">);</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">bwr</span><span class="p">.</span><span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">readbuf</span><span class="p">;</span>
        <span class="c1">// 向 binder 驱动要个事情来做</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_WRITE_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bwr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 接收并解析请求，最终将调用 svcmgr_handler 函数</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">binder_parse</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">readbuf</span><span class="p">,</span> <span class="n">bwr</span><span class="p">.</span><span class="n">read_consumed</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>4.1、解析请求：<code class="language-plaintext highlighter-rouge">service_manager.c::binder_parse()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">binder_parse</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">binder_io</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
                 <span class="kt">uintptr_t</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">binder_handler</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uintptr_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="n">BR_TRANSACTION</span><span class="p">:</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="nc">binder_transaction_data</span> <span class="o">*</span><span class="n">txn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">binder_transaction_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
            <span class="c1">// ...</span>
            <span class="c1">// 如果处理函数不为空</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="n">rdata</span><span class="p">[</span><span class="mi">256</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
                <span class="k">struct</span> <span class="nc">binder_io</span> <span class="n">msg</span><span class="p">;</span>
                <span class="k">struct</span> <span class="nc">binder_io</span> <span class="n">reply</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

                <span class="n">bio_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">,</span> <span class="n">rdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rdata</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
                <span class="n">bio_init_from_txn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">txn</span><span class="p">);</span>
                <span class="c1">// 处理请求</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">txn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">);</span>
                <span class="c1">// ...</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>5、处理请求：<code class="language-plaintext highlighter-rouge">service_manager.c::svcmgr_handler()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">svcmgr_handler</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_transaction_data</span> <span class="o">*</span><span class="n">txn</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_io</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="nc">binder_io</span> <span class="o">*</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">svcinfo</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">strict_policy</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">allow_isolated</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">dumpsys_priority</span><span class="p">;</span>

    <span class="c1">// BINDER_SERVICE_MANAGER 魔数，定义为 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">BINDER_SERVICE_MANAGER</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">==</span> <span class="n">PING_TRANSACTION</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Equivalent to Parcel::enforceInterface(), reading the RPC</span>
    <span class="c1">// header with the strict mode policy mask and the interface name.</span>
    <span class="c1">// Note that we ignore the strict_policy and don't propagate it</span>
    <span class="c1">// further (since we do no outbound RPCs anyway).</span>
    <span class="n">strict_policy</span> <span class="o">=</span> <span class="n">bio_get_uint32</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bio_get_string16</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">!=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">svcmgr_id</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">||</span>
        <span class="n">memcmp</span><span class="p">(</span><span class="n">svcmgr_id</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">svcmgr_id</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"invalid id %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str8</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sehandle</span> <span class="o">&amp;&amp;</span> <span class="n">selinux_status_updated</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">selabel_handle</span> <span class="o">*</span><span class="n">tmp_sehandle</span> <span class="o">=</span> <span class="n">selinux_android_service_context_handle</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tmp_sehandle</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">selabel_close</span><span class="p">(</span><span class="n">sehandle</span><span class="p">);</span>
            <span class="n">sehandle</span> <span class="o">=</span> <span class="n">tmp_sehandle</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SVC_MGR_GET_SERVICE</span><span class="p">:</span> <span class="c1">// getService()</span>
    <span class="k">case</span> <span class="n">SVC_MGR_CHECK_SERVICE</span><span class="p">:</span> <span class="c1">// checkService()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">bio_get_string16</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">do_find_service</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_euid</span><span class="p">,</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_pid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">bio_put_ref</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SVC_MGR_ADD_SERVICE</span><span class="p">:</span> <span class="c1">// addService()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">bio_get_string16</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">bio_get_ref</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="n">allow_isolated</span> <span class="o">=</span> <span class="n">bio_get_uint32</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">dumpsys_priority</span> <span class="o">=</span> <span class="n">bio_get_uint32</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">do_add_service</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_euid</span><span class="p">,</span> <span class="n">allow_isolated</span><span class="p">,</span>
            <span class="n">dumpsys_priority</span><span class="p">,</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_pid</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SVC_MGR_LIST_SERVICES</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// listService()</span>
        <span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bio_get_uint32</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="kt">uint32_t</span> <span class="n">req_dumpsys_priority</span> <span class="o">=</span> <span class="n">bio_get_uint32</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc_can_list</span><span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_pid</span><span class="p">,</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">sender_euid</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">svclist</span><span class="p">;</span>
        <span class="c1">// walk through the list of services n times skipping services that</span>
        <span class="c1">// do not support the requested priority</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">dumpsys_priority</span> <span class="o">&amp;</span> <span class="n">req_dumpsys_priority</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
                <span class="n">n</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bio_put_string16</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nl">default:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">bio_put_uint32</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 以上，实现了所有在 IServiceManager 中定义的业务函数</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>总结：</strong></p><p>1、<code class="language-plaintext highlighter-rouge">svcmgr_handler</code> 函数实现了所有在 IServiceManager 中定义的业务函数</p><h3 id="service-注册">service 注册</h3><p>1、<code class="language-plaintext highlighter-rouge">service_manager.c::do_add_service()</code> 函数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">do_add_service</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">,</span><span class="n">uid_t</span> <span class="n">uid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allow_isolated</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dumpsys_priority</span><span class="p">,</span>
    <span class="n">pid_t</span> <span class="n">spid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">svcinfo</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// ①检查服务是否可以注册</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc_can_register</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">spid</span><span class="p">,</span> <span class="n">uid</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ②检查服务是否已存在，根据服务名的长度和名字是否相同来判断</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">find_svc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 通知 service 已挂</span>
            <span class="n">svcinfo_death</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">si</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 服务已存在，更新一下</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">si</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ③保存服务</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">));</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="c1">// service 退出的通知函数 svcinfo_death</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">death</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">svcinfo_death</span><span class="p">;</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">death</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">allow_isolated</span> <span class="o">=</span> <span class="n">allow_isolated</span><span class="p">;</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">dumpsys_priority</span> <span class="o">=</span> <span class="n">dumpsys_priority</span><span class="p">;</span>
        <span class="c1">// 当前 service 的 next 指针指向表头</span>
        <span class="n">si</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">svclist</span><span class="p">;</span>
        <span class="c1">// 保存 service 到表头</span>
        <span class="n">svclist</span> <span class="o">=</span> <span class="n">si</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">binder_acquire</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
    <span class="n">binder_link_to_death</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">death</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、检查服务是否可以注册： <code class="language-plaintext highlighter-rouge">service_manager.c::svc_can_register()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">svc_can_register</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">spid</span><span class="p">,</span>
    <span class="n">uid_t</span> <span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">perm</span> <span class="o">=</span> <span class="s">"add"</span><span class="p">;</span>
    <span class="c1">// 不允许 app 注册服务</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">multiuser_get_app_id</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">AID_APP</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 检查是否有某项权限（add/find）</span>
    <span class="c1">// 高版本是通过 selinux 来检查的</span>
    <span class="c1">// 低版本通过定义一个 allowed 数组来判断，如果没有达到 root 和 system 权</span>
    <span class="c1">// 限是无法添加的</span>
    <span class="k">return</span> <span class="n">check_mac_perms_from_lookup</span><span class="p">(</span><span class="n">spid</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">str8</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="servicemanager-存在的意义">ServiceManager 存在的意义</h3><ul><li>1、ServiceManager 能集中管理系统中的所有服务，能够施加权限控制，并不是所有 的进程都可注册服务；<li>2、ServiceManager 支持通过字符串名称来查找对应的 service，有点像 DNS；<li>3、server 进程可能会挂掉，如果让每个 client 自己来检测的话压力会很大，现在 只需向 ServiceManager查询一下就能够轻松知道</ul><h2 id="service-以及它的-client">service 以及它的 client</h2><p>以 MediaPlayerService 和 它的 client 为例</p><h3 id="client-查询-service">client 查询 service</h3><p>一个 client 若想使用某个 service，就必须通过调用 ServiceManager::getService() 函数来查询该 service。比如：IMediaDeathNotifier.cpp::getMediaPlayerService()</p><p>1、查询服务 <code class="language-plaintext highlighter-rouge">IMediaDeathNotifier.cpp::getMediaPlayerService()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayerService</span><span class="o">&gt;</span> <span class="n">IMediaDeathNotifier</span><span class="o">::</span><span class="n">getMediaPlayerService</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Mutex</span><span class="o">::</span><span class="n">Autolock</span> <span class="n">_l</span><span class="p">(</span><span class="n">sServiceLock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sMediaPlayerService</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">defaultServiceManager</span><span class="p">();</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">binder</span><span class="p">;</span>
        <span class="c1">// 查询 media.player service, 如果还没注册上则每隔 0.5s 查询一次，直到</span>
        <span class="c1">// 注册成功</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="c1">// 想要与 service 通信，必须拿到一个 BpBinder 对象</span>
            <span class="n">binder</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">getService</span><span class="p">(</span><span class="n">String16</span><span class="p">(</span><span class="s">"media.player"</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">binder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span> <span class="c1">// 0.5 s</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sDeathNotifier</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sDeathNotifier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DeathNotifier</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// 注册服务死亡通知，用于服务挂掉时接收通知</span>
        <span class="n">binder</span><span class="o">-&gt;</span><span class="n">linkToDeath</span><span class="p">(</span><span class="n">sDeathNotifier</span><span class="p">);</span>
        <span class="c1">// 调用 asInterface() 方法拿到 BpMediaPlayerService 对象之后，就能够使</span>
        <span class="c1">// 用其中的业务函数了，比如：createMetadataRetriever()、</span>
        <span class="c1">// createMediaRecorder() 等，当然也仅仅是交给其打包转发而已，具体的实</span>
        <span class="c1">// 现在 BnMediaPlayerService</span>
        <span class="n">sMediaPlayerService</span> <span class="o">=</span> <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IMediaPlayerService</span><span class="o">&gt;</span><span class="p">(</span><span class="n">binder</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sMediaPlayerService</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、转发业务码：<code class="language-plaintext highlighter-rouge">BnMediaPlayerService::onTransact()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">BnMediaPlayerService</span><span class="o">::</span><span class="n">onTransact</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">CREATE</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayerClient</span><span class="o">&gt;</span> <span class="n">client</span> <span class="o">=</span>
                <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IMediaPlayerClient</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">readStrongBinder</span><span class="p">());</span>
            <span class="n">audio_session_t</span> <span class="n">audioSessionId</span> <span class="o">=</span> <span class="p">(</span><span class="n">audio_session_t</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
            <span class="c1">// 子类要实现 create() 虚函数</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayer</span><span class="o">&gt;</span> <span class="n">player</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">audioSessionId</span><span class="p">);</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">player</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">CREATE_MEDIA_RECORDER</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="k">const</span> <span class="n">String16</span> <span class="n">opPackageName</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">readString16</span><span class="p">();</span>
            <span class="c1">// 子类要实现 createMediaRecorder() 虚函数</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaRecorder</span><span class="o">&gt;</span> <span class="n">recorder</span> <span class="o">=</span> <span class="n">createMediaRecorder</span><span class="p">(</span><span class="n">opPackageName</span><span class="p">);</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">recorder</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">CREATE_METADATA_RETRIEVER</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="c1">// 子类要实现 createMetadataRetriever() 虚函数</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaMetadataRetriever</span><span class="o">&gt;</span> <span class="n">retriever</span> <span class="o">=</span> <span class="n">createMetadataRetriever</span><span class="p">();</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">retriever</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ADD_BATTERY_DATA</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="kt">uint32_t</span> <span class="n">params</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
            <span class="c1">// 子类要实现  addBatteryData() 虚函数</span>
            <span class="n">addBatteryData</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">PULL_BATTERY_DATA</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="c1">// 子类要实现  pullBatteryData() 虚函数</span>
            <span class="n">pullBatteryData</span><span class="p">(</span><span class="n">reply</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">LISTEN_FOR_REMOTE_DISPLAY</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="k">const</span> <span class="n">String16</span> <span class="n">opPackageName</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">readString16</span><span class="p">();</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IRemoteDisplayClient</span><span class="o">&gt;</span> <span class="n">client</span><span class="p">(</span>
                    <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IRemoteDisplayClient</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">readStrongBinder</span><span class="p">()));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">String8</span> <span class="n">iface</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">readString8</span><span class="p">());</span>
            <span class="c1">// 子类要实现 listenForRemoteDisplay() 虚函数</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IRemoteDisplay</span><span class="o">&gt;</span> <span class="n">display</span><span class="p">(</span><span class="n">listenForRemoteDisplay</span><span class="p">(</span><span class="n">opPackageName</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">iface</span><span class="p">));</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">display</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">GET_CODEC_LIST</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="c1">// 子类要实现 getCodecList() 虚函数</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaCodecList</span><span class="o">&gt;</span> <span class="n">mcl</span> <span class="o">=</span> <span class="n">getCodecList</span><span class="p">();</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">mcl</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="k">return</span> <span class="n">BBinder</span><span class="o">::</span><span class="n">onTransact</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="service-工作">service 工作</h3><p>具体的业务逻辑是由 MediaPlayerService.cpp 来实现的，以 create() 为例来看一下</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayer</span><span class="o">&gt;</span> <span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayerClient</span><span class="o">&gt;&amp;</span> <span class="n">client</span><span class="p">,</span>
        <span class="n">audio_session_t</span> <span class="n">audioSessionId</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCallingPid</span><span class="p">();</span>
    <span class="kt">int32_t</span> <span class="n">connId</span> <span class="o">=</span> <span class="n">android_atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mNextConnId</span><span class="p">);</span>

    <span class="c1">// 创建 Client 对象</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">Client</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Client</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">connId</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="n">audioSessionId</span><span class="p">,</span>
            <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCallingUid</span><span class="p">());</span>

    <span class="n">wp</span><span class="o">&lt;</span><span class="n">Client</span><span class="o">&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">Mutex</span><span class="o">::</span><span class="n">Autolock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mLock</span><span class="p">);</span>
        <span class="c1">// 记录 client</span>
        <span class="n">mClients</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 返回 client 引用</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>总结：</strong></p><ul><li>BpXxxService：client 端访问 service 时，service 端派出的代理；<li>BnXxxService：service 端负责转发 service 代理发送的请求；<li>XxxService：service 端真正实现业务逻辑的地方；</ul><h2 id="拓展思考">拓展思考</h2><p>binder 驱动的实现：</p><ul><li>驱动代码是在 kernel/drivers/staing/android/binder.c 中（Android 4.4），该目录 下还有一个 binder.h 头文件<li>/proc/binder 目录下的内容可用来查看 binder 设备的运行情况</ul><h3 id="binder-与线程的关系">binder 与线程的关系</h3><p>以 MediaService 为例，如果程序正常运行，则：</p><ul><li>通过 startThreadPool() 启动一个线程，这个线程在 talkWithDriver()；<li>主线程通过 joinThreadPool() 也在 talkWithDriver()；<li>binder 设备把发起请求的线程牢牢地拴住，必须收到回复才会放它离开；</ul><h3 id="关于-deathrecipient">关于 DeathRecipient</h3><p>字面意思翻译是‘死亡接收者’，也就是说，如果想要收到服务死亡的通知就必须要设 置一个 DeathRecipient</p><p>1、设置 DeathRecipient</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayerService</span><span class="o">&gt;</span> <span class="n">IMediaDeathNotifier</span><span class="o">::</span><span class="n">getMediaPlayerService</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Mutex</span><span class="o">::</span><span class="n">Autolock</span> <span class="n">_l</span><span class="p">(</span><span class="n">sServiceLock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sMediaPlayerService</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 伪代码</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">defaultServiceManager</span><span class="p">();</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">binder</span> <span class="o">=</span> <span class="n">sm</span><span class="o">-&gt;</span><span class="n">getService</span><span class="p">(</span><span class="n">String16</span><span class="p">(</span><span class="s">"media.player"</span><span class="p">));</span>
        <span class="c1">// 注册服务死亡通知，用于服务挂掉时接收通知</span>
        <span class="n">binder</span><span class="o">-&gt;</span><span class="n">linkToDeath</span><span class="p">(</span><span class="n">sDeathNotifier</span><span class="p">);</span>
        <span class="n">sMediaPlayerService</span> <span class="o">=</span> <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IMediaPlayerService</span><span class="o">&gt;</span><span class="p">(</span><span class="n">binder</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sMediaPlayerService</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2、发送 service dead 通知</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">executeCommand</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status_t</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NO_ERROR</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="n">BR_DEAD_BINDER</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">// 收到驱动的指示：service 挂掉了，BpBinder 要做一些事儿了</span>
            <span class="c1">// 至于驱动是如何实现的，则要去分析驱动源码，在此略过</span>
            <span class="n">BpBinder</span> <span class="o">*</span><span class="n">proxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">BpBinder</span><span class="o">*</span><span class="p">)</span><span class="n">mIn</span><span class="p">.</span><span class="n">readPointer</span><span class="p">();</span>
            <span class="c1">// 通知 service 挂掉了</span>
            <span class="n">proxy</span><span class="o">-&gt;</span><span class="n">sendObituary</span><span class="p">();</span>
            <span class="n">mOut</span><span class="p">.</span><span class="n">writeInt32</span><span class="p">(</span><span class="n">BC_DEAD_BINDER_DONE</span><span class="p">);</span>
            <span class="n">mOut</span><span class="p">.</span><span class="n">writePointer</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">proxy</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.1、<code class="language-plaintext highlighter-rouge">BpBinder.cpp::sendObituary()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">BpBinder</span><span class="o">::</span><span class="n">sendObituary</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obits</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="n">obits</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 逐个发送报告</span>
            <span class="n">reportOneDeath</span><span class="p">(</span><span class="n">obits</span><span class="o">-&gt;</span><span class="n">itemAt</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">delete</span> <span class="n">obits</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2.2、<code class="language-plaintext highlighter-rouge">BpBinder.cpp::reportOneDeath()</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">BpBinder</span><span class="o">::</span><span class="n">reportOneDeath</span><span class="p">(</span><span class="k">const</span> <span class="n">Obituary</span><span class="o">&amp;</span> <span class="n">obit</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">DeathRecipient</span><span class="o">&gt;</span> <span class="n">recipient</span> <span class="o">=</span> <span class="n">obit</span><span class="p">.</span><span class="n">recipient</span><span class="p">.</span><span class="n">promote</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">recipient</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// 回调 DeathRecipient 对象的 binderDied() 方法</span>
    <span class="n">recipient</span><span class="o">-&gt;</span><span class="n">binderDied</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>3、如何接收到 service dead 通知</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">IMediaDeathNotifier</span><span class="o">::</span><span class="n">DeathNotifier</span><span class="o">::</span><span class="n">binderDied</span><span class="p">(</span><span class="k">const</span> <span class="n">wp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">who</span> <span class="n">__unused</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaDeathNotifier</span><span class="o">&gt;</span> <span class="n">notifier</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">iter</span><span class="p">].</span><span class="n">promote</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">notifier</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 以 MediaPlayer 为例分析</span>
            <span class="n">notifier</span><span class="o">-&gt;</span><span class="n">died</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>4、接下来看 MediaPlayer 内部如何处理</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">MediaPlayer</span><span class="o">::</span><span class="n">died</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"died"</span><span class="p">);</span>
    <span class="c1">// 通用方法，其他的消息比如 MEDIA_PREPARED 等也会从 notify() 发出去</span>
    <span class="n">notify</span><span class="p">(</span><span class="n">MEDIA_ERROR</span><span class="p">,</span> <span class="n">MEDIA_ERROR_SERVER_DIED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MediaPlayer</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span><span class="kt">int</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ext1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ext2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"message received msg=%d, ext1=%d, ext2=%d"</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ext1</span><span class="p">,</span> <span class="n">ext2</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="n">MEDIA_ERROR</span><span class="p">:</span>
            <span class="n">ALOGE</span><span class="p">(</span><span class="s">"error (%d, %d)"</span><span class="p">,</span> <span class="n">ext1</span><span class="p">,</span> <span class="n">ext2</span><span class="p">);</span>
            <span class="c1">// 处理异常</span>
            <span class="k">break</span><span class="p">;</span>
            <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="匿名-service">匿名 service</h3><p>所谓匿名 service 就是没有注册到 ServiceManager 中的 Service；但既然是一个 Service，那就表明它确实是一个基于 Binder 通信的 C/S 结构。还是以 MediaPlayerService 分析。</p><p>1、<code class="language-plaintext highlighter-rouge">IMediaPlayerService.cpp::onTransact()</code> CREATE 命令</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">status_t</span> <span class="n">BnMediaPlayerService</span><span class="o">::</span><span class="n">onTransact</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span>
    <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">CREATE</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CHECK_INTERFACE</span><span class="p">(</span><span class="n">IMediaPlayerService</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayerClient</span><span class="o">&gt;</span> <span class="n">client</span> <span class="o">=</span>
                <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IMediaPlayerClient</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">readStrongBinder</span><span class="p">());</span>
            <span class="n">audio_session_t</span> <span class="n">audioSessionId</span> <span class="o">=</span> <span class="p">(</span><span class="n">audio_session_t</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">readInt32</span><span class="p">();</span>
            <span class="c1">// 子类实现 create() 虚函数创建一个 IMediaPlayer 对象</span>
            <span class="c1">// 此后 client 就可以直接使用 IMediaPlayer 来跨进程执行函数调用</span>
            <span class="n">sp</span><span class="o">&lt;</span><span class="n">IMediaPlayer</span><span class="o">&gt;</span> <span class="n">player</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">audioSessionId</span><span class="p">);</span>
            <span class="c1">// 将 binder 作为一种特殊的数据类型来处理</span>
            <span class="n">reply</span><span class="o">-&gt;</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">IInterface</span><span class="o">::</span><span class="n">asBinder</span><span class="p">(</span><span class="n">player</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>以上代码所展示的 C/S 结构：</p><ul><li>BpMediaPlayer：由 MediaPlayerClient 使用，调用 IMediaPlayer 提供的业务接口；<li>BnMediaPlayer：由 MediaPlayerService 使用，处理来自 client 端的业务请求；</ul><p>另外要注意一下 <code class="language-plaintext highlighter-rouge">reply-&gt;writeStrongBinder(IInterface::asBinder(player))</code> 这句， 当 reply 写到 binder 驱动时，驱动可能会特殊处理这种 IBinder 类型的数据，比如 为这个 BBinder 计算生成一个唯一的 handle 值，其实这就相当于在 binder 驱动中注 册了一项服务。通过这种方式，MediaServer 输出了大量的服务，比如 IMediaPlayer、 IMediaRecorder 等</p><h2 id="实践如何实现一个-native-service">实践：<a href="/android/2021/01/04/android-implement-a-native-service/">如何实现一个 native service</a></h2><h2 id="总结">总结</h2><h3 id="除了-binder-之外android-中的其他-ipc-手段">除了 binder 之外，Android 中的其他 IPC 手段</h3><p>1、pipe、socket、文件共享、共享内存</p><h3 id="binder-相较于其他-ipc-手段的优点">binder 相较于其他 IPC 手段的优点</h3><p>1、一次 copy； 2、有校验，安全；</p><h2 id="从一个-anr-实例看-binder-整体调用流程">从一个 anr 实例看 binder 整体调用流程</h2><pre><code class="language-log">native: #02 pc 000000000005a844  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+260)
native: #03 pc 000000000005b718  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, int*)+360)
native: #04 pc 000000000005b438  /system/lib64/libbinder.so (android::IPCThreadState::transact(int, unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+176)
native: #05 pc 00000000000513e8  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+72)
native: #06 pc 0000000000131558  /system/lib64/libandroid_runtime.so (android_os_BinderProxy_transact(_JNIEnv*, _jobject*, int, _jobject*, _jobject*, int)+152)
at android.os.BinderProxy.transactNative(Native method)
at android.os.BinderProxy.transact(Binder.java:1127)
at com.android.internal.app.IBatteryStats$Stub$Proxy.getStatisticsStream(IBatteryStats.java:1364)
at com.android.internal.os.BatteryStatsHelper.getStats(BatteryStatsHelper.java:1032)
at com.android.internal.os.BatteryStatsHelper.load(BatteryStatsHelper.java:1023)
at com.android.internal.os.BatteryStatsHelper.getStats(BatteryStatsHelper.java:258)
at com.android.settings.fuelgauge.BatteryInfo.getBatteryInfo(BatteryInfo.java:151)
at com.android.settings.fuelgauge.BatteryInfo.getBatteryInfo(BatteryInfo.java:145)
</code></pre><p>梳理下整体调用流程</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>客户端 -&gt; 代理服务端 (Proxy)-&gt; 服务端(Binder) -&gt; native 层 Binder -&gt; Binder 驱动
【java 层 Client 发起请求】BatteryStatsHelper#getStats() -&gt;
【java 层服务 Proxy】IBatteryStats.Stub.Proxy#getStatisticsStream() -&gt;
【java 层 Binder】BinderProxy#transact() -&gt; BinderProxy#transactNative() -&gt;
【native 层 BinderProxy】android_util_Binder.cpp::android_os_BinderProxy_transact() -&gt; BpBinder.cpp::transact() -&gt; 
【native 层 IPCThreadState】IPCThreadState.cpp::transact() -&gt; IPCThreadState.cpp::waitForResponse() -&gt; IPCThreadState.cpp::talkWithDriver() -&gt; 
【native 层 Binder 驱动】通过 ioctl() 与 binder 驱动交互
</pre></table></code></div></div><h2 id="参考资料">参考资料</h2><ul><li>《深入理解Android卷1》（邓凡平）第六章：深入理解 Binder</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>android</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/framework/" class="post-tag no-text-decoration" >framework</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Android binder 架构：native 层 - sleticalboy&url=https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Android binder 架构：native 层 - sleticalboy&u=https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Android binder 架构：native 层 - sleticalboy&url=https://sleticalboy.github.io/android/2020/04/26/android-binder-architecture-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/java/2021/04/20/java-class-loader-and-gc/">Java 类加载与垃圾回收</a><li><a href="/net/2021/04/09/http-and-https/">HTTP 和 HTTPS</a><li><a href="/java/2021/02/19/java-hashmap/">Java 容器之 HashMap（java 8）</a><li><a href="/java/2021/04/07/java-thread-pool/">Java 线程池</a><li><a href="/android/2019/04/09/app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-01/">app 启动流程源码分析-1</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/framework/">framework</a> <a class="post-tag" href="/tags/english/">english</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/open-source/">open source</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/git/">git</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/android/2021/02/02/andorid-input-subsystem-3/"><div class="card-body"> <span class="timeago small" > Feb 2 <i class="unloaded">2021-02-02T10:57:35+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android 输入子系统3：InputDispatcher 对事件分发</h3><div class="text-muted small"><p> 涉及到的源代码及路径： frameworks/base/core/java/android/view/WindowManagerImpl.java frameworks/base/core/java/android/view/WindowManagerGlobal.java frameworks/base/core/java/android/view/ViewRootImpl.java fr...</p></div></div></a></div><div class="card"> <a href="/android/2019/04/09/app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-01/"><div class="card-body"> <span class="timeago small" > Apr 9, 2019 <i class="unloaded">2019-04-09T05:38:47+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>app 启动流程源码分析-1</h3><div class="text-muted small"><p> 源码 基于 android 8.0 从点击桌面 app 图标到 ActivityThread 的 main() 方法执行 先来两张图(先凑合下吧，没找到合适的画图工具，找到了再补上=_=) Launcher /packages/apps/Launcher2/src/com/android/launcher2/Launcher.java 什么是 Launcher ...</p></div></div></a></div><div class="card"> <a href="/android/2019/04/13/app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-02/"><div class="card-body"> <span class="timeago small" > Apr 13, 2019 <i class="unloaded">2019-04-13T23:40:34+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>app 启动流程分析-2</h3><div class="text-muted small"><p> 源码 基于 android 8.0 从 ActivityThread 的 main() 方法执行到页面显示 开篇之前，先思考以下几个问题 Q1: Application 是如何创建的？ Q2: Application 的 attachBaseContext() 为什么会在 onCreate() 方法之前调用？ Q3: Activity 是如何被创建的？ Q4: A...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/git/2020/04/25/git-commands/" class="btn btn-outline-primary"><p>git 常用命令</p></a> <a href="/linux/2020/05/09/setup-a-new-os/" class="btn btn-outline-primary"><p>Ubuntu 新系统常用软件安装</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/sleticalboy">BenLee</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/framework/">framework</a> <a class="post-tag" href="/tags/english/">english</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/open-source/">open source</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/git/">git</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://sleticalboy.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
